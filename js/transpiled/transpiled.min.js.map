{"version":3,"sources":["assets.js","device.js","header.js","media.js","pre_load.js","scroll_trigger.js","sound.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"transpiled.min.js","sourcesContent":["/*\r\n * Created by Josh on 17/06/2017.\r\n */\r\n\r\nconst assets = {\r\n\r\n\r\n    sounds: [\r\n        {\r\n            id: \"Chirp\",\r\n            key: \"chirp\",\r\n            volume: 0.5,\r\n            group: \"a\",\r\n            position: 1,\r\n            template: 'index',\r\n            load: ()=>{\r\n                media.sound.play('Chirp')\r\n                animate()\r\n            },\r\n            error: ()=>{\r\n                animate()\r\n            }\r\n        },\r\n        {\r\n            id: \"Woosh\",\r\n            key: \"woosh\",\r\n            volume: 0.5,\r\n            group: \"a\",\r\n            template: 'contact',\r\n            position: 1\r\n        },\r\n        {\r\n            id: \"Click\",\r\n            key: \"click\",\r\n            volume: 0.5,\r\n            group: \"a\",\r\n            template: 'contact',\r\n            position: 1\r\n        },\r\n        {\r\n            id: \"Error\",\r\n            key: \"error\",\r\n            template: 'contact',\r\n            volume: 0.5,\r\n            group: \"a\",\r\n            position: 1\r\n        },\r\n        {\r\n            id: \"Success\",\r\n            key: \"success\",\r\n            template: 'contact',\r\n            volume: 0.5,\r\n            group: \"a\",\r\n            position: 1\r\n        }\r\n    ],\r\n    images: [\r\n        //{\r\n        //    id: 'middle',\r\n        //    key: 'home/Middle-f',\r\n        //    template: 'landing',\r\n        //    target: '#landing-image-4',\r\n        //    load: function () {\r\n        //        $(this.target).attr('src', this.src);\r\n        //    },\r\n        //    speed: {\r\n        //        cap: 3000\r\n        //    },\r\n        //    errorType: 'connection-iffy'\r\n        //}\r\n    ]\r\n};","const device = function () {\r\n    return {\r\n\r\n        sizes: {\r\n            mobile: {\r\n                SMALL: {\r\n                    w: 320, h: 530\r\n                },\r\n                MEDIUM: {\r\n                    w: 535, h: 850\r\n                },\r\n                LARGE: {\r\n                    w: 641, h: 1030\r\n                }\r\n            },\r\n            tablet: {\r\n                SMALL: {\r\n                    w: 770, h: 1026\r\n                },\r\n                MEDIUM: {\r\n                    w: 800, h: 1280\r\n                },\r\n                LARGE: {\r\n                    w: 920, h: 1380\r\n                }\r\n            }\r\n        },\r\n\r\n        touch: (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),\r\n\r\n        touch_types: function () {\r\n            if (window.navigator.pointerEnabled) {\r\n                return {\r\n                    end: 'pointerup',\r\n                    start: 'pointerdown',\r\n                    move: 'pointermove',\r\n                    enter: 'pointerenter',\r\n                    leave: 'pointerleave'\r\n                }\r\n            } else if (window.navigator.msPointerEnabled) {\r\n                return {\r\n                    end: 'MSPointerUp',\r\n                    start: 'MSPointerDown',\r\n                    move: 'MSPointerMove',\r\n                    enter: 'MSPointerEnter',\r\n                    leave: 'MSPointerLeave'\r\n                }\r\n            } else {\r\n                return {\r\n                    end: 'touchend',\r\n                    start: 'touchstart',\r\n                    move: 'mousemove',\r\n                    enter: 'mouseenter',\r\n                    leave: 'mouseleave'\r\n                }\r\n            }\r\n        }(),\r\n\r\n        click(){\r\n            return this.touch ? 'touchend' : 'click';\r\n        },\r\n\r\n        is_device: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Windows Phone/i.test(navigator.userAgent),\r\n\r\n        o_s: function () {\r\n            var OSName = \"Unknown OS\";\r\n            if (navigator.appVersion.indexOf(\"Win\") != -1) OSName = \"Windows\";\r\n            if (navigator.appVersion.indexOf(\"Mac\") != -1) OSName = \"OSX\";\r\n            if (navigator.appVersion.indexOf(\"X11\") != -1) OSName = \"UNIX\";\r\n            if (navigator.appVersion.indexOf(\"Linux\") != -1) OSName = \"Linux\";\r\n            if (/Android/i.test(navigator.userAgent)) OSName = 'Android';\r\n            if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) OSName = 'iOS';\r\n            return OSName;\r\n        }(),\r\n\r\n        browser: function () {\r\n            var browser = '';\r\n            if (navigator.userAgent.indexOf('Edge/') > -1) {\r\n                browser = 'Edge';\r\n            } else if (navigator.userAgent.indexOf('Chrome') > -1) {\r\n                browser = 'Chrome';\r\n                if (navigator.userAgent.indexOf('SamsungBrowser') > -1) {\r\n                    browser = 'Samsung-Browser';\r\n                }\r\n            } else if (!!window.MSInputMethodContext || navigator.userAgent.indexOf('MSIE') > -1) {\r\n                browser = 'MSIE';\r\n            } else if (navigator.userAgent.indexOf('Firefox') > -1) {\r\n                browser = 'Firefox';\r\n            } else if (navigator.userAgent.indexOf('Safari') > -1) {\r\n                browser = 'Safari';\r\n            }\r\n            return browser;\r\n        }(),\r\n\r\n        port() {\r\n            return window.innerHeight > window.innerWidth;\r\n        },\r\n\r\n        land() {\r\n            return window.innerHeight < window.innerWidth;\r\n        },\r\n        is_device_size(dimensions) {\r\n            if (dimensions === undefined) {\r\n                dimensions = this.sizes.mobile.LARGE;\r\n            }\r\n            console.log(dimensions);\r\n            return (screen.height <= dimensions.h && screen.width <= dimensions.w) ||\r\n                (screen.height <= dimensions.w && screen.height <= dimensions.h);\r\n        },\r\n        hover_support() {\r\n            return {\r\n                in: this.touch ? this.touch_types.start : this.touch_types.enter,\r\n                out: this.touch ? this.touch_types.end : this.touch_types.leave\r\n            }\r\n        }\r\n    }\r\n}();","//const media = function () {\r\n\r\nlet header_visible = false,\r\n  header_at_top = true;\r\n\r\nconst check_header_scroll = (e) => {\r\n  // if ($(e.currentTarget).scrollTop() > 100) {\r\n  //   TweenMax.to($('.-menu-icon, #home-button'), 0.2, {scale: 0.7, transformOrigin: '50% 0%'})\r\n  // } else {\r\n  //   TweenMax.to($('.-menu-icon, #home-button'), 0.2, {scale: 1, transformOrigin: '50% 0%'})\r\n  // }\r\n\r\n  if (header_visible) {\r\n    show_menu_items()\r\n  }\r\n}\r\n\r\nwindow.addEventListener(\"scroll\", check_header_scroll);\r\nwindow.addEventListener(\"mousewheel\", check_header_scroll);\r\n\r\n\r\nconst index_clicks = () => {\r\n  let hover_support = device.hover_support();\r\n  $(\".menu-icon\").on(\"click\", show_menu_items);\r\n\r\n\r\n  if (!device.touch) {\r\n    $(\".-menu-icon:not(.menu-icon)\").on(\r\n      hover_support.in + \" \" +\r\n      hover_support.out\r\n      , hover_menu_items)\r\n  }\r\n\r\n};\r\n\r\nconst show_menu_icon = ($menu) => {\r\n  TweenMax.fromTo($menu || \".menu-icon\", 0.288, {left: \"-100%\"}, {autoAlpha: 1, left: 0})\r\n};\r\n\r\nconst hover_menu_items = (e) => {\r\n  let $b = $(e.currentTarget),\r\n    on = e.type === device.hover_support().in;\r\n\r\n  TweenMax.to($b.children(\".-icon-name\"), 0.3,\r\n    {\r\n      left: on ? $b.outerWidth() + 15 : 0,\r\n      autoAlpha: on ? 1 : 0\r\n    }\r\n  )\r\n\r\n};\r\n\r\nconst show_menu_items = (e) => {\r\n  var $b = $(e ? e.currentTarget : \".menu-icon\"),\r\n    $icons = $b.siblings().find(\".-menu-icon\"),\r\n    active = $b.hasClass(\"__active\"),\r\n    dur = 0.3,\r\n    call_back = active ? \"onStart\" : \"onComplete\",\r\n    vars = {\r\n      ease: Quart.easeInOut,\r\n      left: active ? \"-100%\" : 0,\r\n      autoAlpha: 1\r\n    };\r\n\r\n  header_visible = !active;\r\n\r\n  vars[call_back] = function (e) {\r\n    if (device.touch || e.type != \"click\") {\r\n      let new_e = e || {},\r\n        h_s = device.hover_support();\r\n      new_e.currentTarget = this.target;\r\n      new_e.type = active ? h_s.out : h_s.in;\r\n      hover_menu_items(new_e)\r\n    }\r\n  };\r\n\r\n  vars[call_back + \"Params\"] = [e];\r\n\r\n  $b[active ? \"removeClass\" : \"addClass\"](\"__active\");\r\n\r\n  TweenMax.staggerTo($icons, dur, vars, dur / 2)\r\n};\r\n\r\n","/*\r\n * Created by Josh on 17/06/2017.\r\n */\r\n\r\nconst media = function () {\r\n    const act = {\r\n        process_images(asset) {\r\n            asset.load_type = \"load\";\r\n            asset.type = \"html_asset\";\r\n            asset.image_asset = true;\r\n            asset.src =\r\n                (asset.local || (media.PATH +\r\n                \"image/upload/f_auto,q_99/v20000/\" +\r\n                (asset.template || \"\") +\r\n                (asset.category || \"/product/\") +\r\n                asset.key));\r\n            asset.element = new Image();\r\n        },\r\n\r\n        process_videos(asset) {\r\n            /*\r\n                Needs expanding to support .ogg\r\n             */\r\n\r\n            asset.load_type = \"canplaythrough\";\r\n            asset.type = \"video\";\r\n            asset.image_asset = true;\r\n            asset.src = asset.local + asset.id + '.mp4';\r\n            asset.element = document.createElement('video');\r\n        },\r\n\r\n        process_sounds(asset) {\r\n            asset.sound_asset = true;\r\n            asset.load_type = media.sound.WEB_AUDIO ? null : \"canplaythrough\";\r\n            asset.type = media.sound.WEB_AUDIO ? 'web_audio' : \"html_asset\";\r\n            asset.src = (asset.local || media.sound.SOUND_PATH + asset.key) + media.sound.EXTENSION;\r\n        }\r\n\r\n\r\n    };\r\n\r\n    function process_assets(types) {\r\n        var t = types.constructor === Array ? types : [types];\r\n        t.forEach(type => {\r\n            assets[type].forEach(a => {\r\n                a.position = a.position || 9999;\r\n                act[\"process_\" + type](a);\r\n               // log(\"PROCESSED ASSET: \" + a.id);\r\n            });\r\n            order(assets[type]);\r\n        });\r\n    }\r\n\r\n    function Asset(settings) {\r\n        var defaults = {\r\n                id: '',\r\n                src: ''\r\n            },\r\n            type = {\r\n                sound: {\r\n                    volume: 1\r\n                },\r\n                image: {\r\n                    size: {\r\n                        width: null,\r\n                        height: null\r\n                    }\r\n                }\r\n            }\r\n\r\n        $.extend(defaults, settings, settings[type]);\r\n        return defaults;\r\n    }\r\n\r\n    function order(batch) {\r\n        /*\r\n         Sorts the asset array after its been processed so that it can make a more dynamic load order.\r\n         This sort, sorts by the Int value of position.\r\n         */\r\n        batch.sort(function (a, b) {\r\n            return a.position - b.position;\r\n        });\r\n        return batch;\r\n    }\r\n\r\n    function group(assets, group, type) {\r\n        /*\r\n         Groups assets in the array into a smaller batch for mpre precise loading.\r\n         This groups all assets with the variable (string) e.g. 'a' assigened to it.\r\n         */\r\n        return assets.filter(function (a) {\r\n            if (group === 'id') {\r\n                return a[group].indexOf(type) !== -1;\r\n            }\r\n            return a[group] === type;\r\n        });\r\n    }\r\n\r\n    return {\r\n        PATH: '/',\r\n        play_video(elm) {\r\n            elm[0].play();\r\n        },\r\n        pause_video(elm) {\r\n            elm[0].pause();\r\n        },\r\n        get(type, id) {\r\n            var items = assets[type],\r\n                i;\r\n            if (!id) {\r\n                return items;\r\n            }\r\n            return items.find((item) => {\r\n                return item.id === id;\r\n            });\r\n        },\r\n        init(group_items, template) {\r\n            process_assets([\"sounds\", 'images']);\r\n            /*\r\n             Chain loading the assets by group.\r\n             Syntatically; its hard to read, might need a better implementation.\r\n             Promises might work well here.\r\n             */\r\n\r\n            media.pre_load.chain_load(\r\n                    group(assets['sounds'], group_items, template))\r\n                .then(function () {})\r\n            /*\r\n             Initializes loading of all assets assigned to the type e.g. 'sounds' or 'images'.\r\n             */\r\n        }\r\n    }\r\n}()\r\n\r\n\r\n\r\n\r\n\r\n","/*\r\n * Created by Josh on 17/06/2017.\r\n */\r\n//var pre_load = new Pre_load();\r\nconst pre_load = function () {\r\n\r\n    function web_audio_buffered(buffer) {\r\n        this.element = buffer;\r\n        /*\r\n         Data loaded and info is stored as buffer.\r\n         */\r\n        media.pre_load.load_finished({\r\n            data: {\r\n                asset: this\r\n            },\r\n            success: buffer\r\n        });\r\n        /*\r\n            cold checks if the data has been played without being initially preloaded,\r\n            Then it plays the audio after being loaded.\r\n\r\n            if (cold) {\r\n                play_web_audio(this);\r\n            }\r\n        */\r\n    }\r\n\r\n    function web_audio_load(data) {\r\n         media.sound.CONTEXT.decodeAudioData(\r\n            data.xhr.response,\r\n            web_audio_buffered.bind(data.asset)\r\n        );\r\n    }\r\n\r\n    function load(asset){\r\n\r\n        return new Promise((resolve, reject) => {\r\n\r\n            switch(asset.type){\r\n                case 'html_asset':\r\n                    asset.element['on' + asset.load_type] = function () {\r\n                        resolve({\r\n                            asset: asset\r\n                        });\r\n                    };\r\n                    asset.element['onerror'] = function (error) {\r\n                        reject(asset, error);\r\n                    };\r\n                    asset.element.src = asset.src;\r\n                    break;\r\n\r\n                case 'web_audio':\r\n                    var xhr = new XMLHttpRequest();\r\n                    xhr.open(\"GET\", asset.src, true);\r\n                    xhr.responseType = \"arraybuffer\";\r\n                    xhr.onload = function (progress) {\r\n                        media.sound.CONTEXT.decodeAudioData(\r\n                            xhr.response,\r\n                            function(buffer){\r\n                                if(!buffer){\r\n                                    reject(asset, 'FAILED');\r\n                                }\r\n                                asset.element = buffer;\r\n                                /*\r\n                                 Data loaded and info is stored as buffer.\r\n                                 */\r\n                                resolve({asset : asset});\r\n                                /*\r\n                                    cold checks if the data has been played without being initially preloaded,\r\n                                    Then it plays the audio after being loaded.\r\n\r\n                                    if (cold) {\r\n                                        play_web_audio(this);\r\n                                    }\r\n                                */\r\n                            }\r\n                        );\r\n                    };\r\n                    xhr.onerror = function (error) {\r\n                        reject(asset, error);\r\n                    };\r\n                    try {\r\n                        xhr.send();\r\n                    }catch (e) {\r\n                        reject(asset, 'FAILED: ' + e);\r\n                    }\r\n                    break;\r\n\r\n                case 'video':\r\n                    asset.element['onload'] = function () {\r\n                        resolve({\r\n                            asset: asset\r\n                        });\r\n                    };\r\n                    asset.element['onerror'] = function (error) {\r\n                        reject(asset, error);\r\n                    };\r\n                    asset.element.appendChild(document.createElement('source'));\r\n                    asset.element.lastChild.type=\"video/mp4\";\r\n                    asset.element.lastChild.src = asset.src;\r\n                case 'js':\r\n\r\n                case 'font':\r\n\r\n            }\r\n        })\r\n        .then((data)=>{\r\n            /*\r\n                Success handler for individual asset load success.\r\n                TODO: have matching case to promise initializer\r\n            */\r\n            load_finished({data: data}, \"SUCCESS\");\r\n        })\r\n        .catch((error)=>{\r\n            /*\r\n                Error handler for individual asset load failure. data structure is a template to support load_finished\r\n            */\r\n            load_finished({data: {asset: error} }, \"FAILED: \" + error);\r\n        })\r\n    }\r\n\r\n    function load_batch(batch, id) {\r\n        var promises = [];\r\n        for (var i = 0; i < batch.length; i++) {\r\n            var asset = batch[i];\r\n            build_asset_info(asset);\r\n            promises.push(load(asset));\r\n        }\r\n        /*\r\n         return promises.reduce((p, fn) =>\r\n            p.then(fn), Promise.resolve([])\r\n        )\r\n         */\r\n        return Promise.all(promises)\r\n            .then(()=> {\r\n                console.log('BATCH: ' + id + ' LOADED, at time: ' + Date.now() % 100000);\r\n            })\r\n\r\n    }\r\n\r\n    function build_asset_url(asset) {\r\n        asset.path = '';\r\n        asset.path += asset.paths.forEach((piece) => {\r\n            return piece;\r\n        });\r\n        return asset;\r\n    }\r\n\r\n    function build_responsive_size(asset) {\r\n        if (!asset.r_size) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    function build_asset_info(asset) {\r\n        if(asset.info_generated){\r\n            return;\r\n        }\r\n        if (asset.image) {\r\n            //$(asset.element).webpify();\r\n            /*\r\n             Cloudinary jquery plugin detects for webp image format support (Chrome)\r\n             */\r\n            build_responsive_size(asset);\r\n            build_asset_url(asset);\r\n            asset.src = $.cloudinary.url(asset.src);\r\n        } else {\r\n            asset.volume = asset.volume || 1;\r\n        }\r\n        asset.init_time = Date.now() % 100000;\r\n        asset.generated_info = true;\r\n    }\r\n\r\n\r\n    function pre_load(batch, call_back, call_back_params) {\r\n        if (batch.loaded) {\r\n            return;\r\n        }\r\n        load_batch(batch, call_back, call_back_params)\r\n    }\r\n\r\n    function load_finished(e, type) {\r\n        /*\r\n         Use Promises for this?\r\n         Call back for all assets that have finished loading.\r\n         Determines weather the asset has failed or successfully loaded.\r\n         */\r\n\r\n        var asset = e.data.asset,\r\n            batch = e.data.batch;\r\n        /*\r\n         Calls the assets load function if assigned.\r\n         */\r\n        if (asset.load) asset.load.apply(asset, asset.load_params);\r\n        if (asset.error) asset.error.apply(asset, asset.load_params);\r\n\r\n        /*\r\n\r\n         */\r\n        if(asset.inject){\r\n            $(asset.target).attr('src', asset.src);\r\n        }\r\n\r\n        /*\r\n         Calls the next item in the pre load batch.\r\n         */\r\n        if (\r\n            asset.load_time_limit &&\r\n            Date.now() % 100000 - asset.init_time > asset.load_time_limit\r\n        ) {\r\n            /*\r\n             Slow connection detected.\r\n             */\r\n        }\r\n        /*\r\n         Logs the result of the load.\r\n         */\r\n        console.log(\r\n            'LOAD STATE: ' +\r\n            type +\r\n            \", For: \" +\r\n            asset.id +\r\n            (asset.position != 9999 ? \", Load Position: \" + asset.position : \"\") +\r\n            (asset.group ? \", Load Group: \" + asset.group : \"\") +\r\n            (asset.init_time\r\n                ? \", Initialized at: \" +\r\n            asset.init_time +\r\n            \" and Loaded at: \" +\r\n            Date.now() % 100000\r\n                : \"\")\r\n        );\r\n    }\r\n\r\n    return {\r\n        act(type, parameters) {\r\n            if (parameters && parameters.constructor != Array) parameters = [parameters];\r\n            return act[type].apply(this, parameters);\r\n        },\r\n\r\n        asset_loaded(e) {\r\n            load_finished(e, \"SUCCESS\");\r\n        },\r\n\r\n        asset_error(e) {\r\n            load_finished(e, \"FAILED\");\r\n        },\r\n\r\n        load_finished(e){\r\n            load_finished(e, e.success ? 'SUCCESS' : 'FAILED')\r\n        },\r\n\r\n        load(type, call_back, call_back_parameters) {\r\n            pre_load(\r\n                type.constructor === Array ? type : media.get(type),\r\n                call_back,\r\n                call_back_parameters\r\n            );\r\n        },\r\n        chain_load(type, id, resolved) {\r\n           return load_batch(type.constructor === Array ? type : media.get(type), id, resolved);\r\n        },\r\n\r\n        init() {\r\n            load(\"images\");\r\n            load(\"sounds\");\r\n            //if(device.o_s === 'Android') {\r\n            //    load(\"videos\");\r\n            //}\r\n        }\r\n    }\r\n}();\r\n","/*\r\n * Created by Josh on 17/06/2017.\r\n */\r\n\r\n\r\nfunction check_scroll_event(trigger, scroller) {\r\n    var offset = get_offset(trigger.static_point || trigger.trigger_elm).top,\r\n        opts = trigger.scroll_options || {},\r\n        elm,\r\n        t_p = trigger.trigger_point($(scroller));\r\n    opts.prev_offset = opts.prev_offset || 0;\r\n    trigger.scroll_options = opts;\r\n    //log(\r\n    //   \"Event: \" +\r\n    //     type +\r\n    //     \", Temp Scroll Height:  \" +\r\n    //     // this[0].scrollHeight +\r\n    //     \", Trigger Elm Offset: \" +\r\n    //     offset +\r\n    //     \", Trigger Point: \" +\r\n    //     trigger.trigger_point\r\n    //);\r\n    /*\r\n     DANGER: when testing offset it can take the offset of the item before the scroll position has properly adjusted.\r\n     May need a delay on measuring offset? An alternative which has performance bonus of not\r\n     measuring extra trigger points is checking against the window height.\r\n\r\n     SET: $(trigger.trigger_elm).height() as a static property so that it does not need to be calculated each event.\r\n    */\r\n\r\n    if (!opts.triggered && offset < t_p) {\r\n        opts.triggered = true;\r\n        if (trigger.settings.in.func) {\r\n            if (trigger.settings.in.transition)trigger.settings.in.transition.totalProgress(1);\r\n            TweenMax.killDelayedCallsTo(media.sound.play)\r\n            trigger.settings.in.transition = trigger.settings.in.func(trigger);\r\n            current_scroll_trigger.in = trigger;\r\n        }\r\n    } else if (\r\n        opts.triggered &&\r\n        ((trigger.settings.hide_below_fold && offset > window.innerHeight) ||\r\n        (!trigger.settings.hide_below_fold && offset > (t_p + $(trigger.trigger_elm).height()) + (trigger.settings.out.offset || 0)))\r\n    ) {\r\n        opts.triggered = false;\r\n        if (trigger.settings.out.func) {\r\n            if (trigger.settings.out.transition)trigger.settings.out.transition.totalProgress(1);\r\n            trigger.settings.out.transition = trigger.settings.out.func(trigger);\r\n            current_scroll_trigger.out = trigger;\r\n        }\r\n    }\r\n    opts.prev_offset = offset;\r\n}\r\n\r\nconst scroll_triggers = function(elm) {\r\n    //Constructor of trigger object\r\n\r\n    var triggers = [],\r\n        id = elm;\r\n\r\n    function fire_scroll_event(event) {\r\n        /*\r\n         Loops through each custom built scroll check and fires them off the one scroll event.\r\n         */\r\n        triggers.forEach((trigger)=>{\r\n            check_scroll_event(trigger, event.currentTarget);\r\n        });\r\n    }\r\n\r\n    return {\r\n        update(temp) {\r\n            $(ANIMATION_CONFIG.SCROLL_TARGET)\r\n                .off(\"mousewheel scroll\", fire_scroll_event)\r\n                .on(\"mousewheel scroll\", fire_scroll_event);\r\n        },\r\n        remove() {\r\n            $(ANIMATION_CONFIG.SCROLL_TARGET).off(\"mousewheel scroll\", fire_scroll_event);\r\n        },\r\n        new_trigger(temp, trigger) {\r\n            scroll_triggers.update();\r\n            triggers.push.apply(triggers, trigger)\r\n        }\r\n    }\r\n}(window);\r\n\r\nfunction Trigger($temp, settings) {\r\n    var defaults = {\r\n        id: \"blank\",\r\n        trigger_elm: $temp.find(\".trigger-point-\" + \"a\"),\r\n        scroll_options: {\r\n            offset: 0,\r\n            triggered: false\r\n        },\r\n        trigger_point: ()=>{\r\n            return window.innerHeight / 2\r\n        },\r\n        settings: {\r\n            in: {\r\n                vars: {\r\n                    autoAlpha: 1\r\n                },\r\n                elm: $temp.find(\".trigger-elm-\" + \"a\"),\r\n                dur: 1,\r\n                func: function () {\r\n                },\r\n                parameters: []\r\n            }\r\n        }\r\n    };\r\n    return $.extend({}, defaults, settings);\r\n}\r\n\r\nvar current_scroll_trigger = {click_index: -1};\r\n\r\nfunction get_top_offset(el) {\r\n    if (el instanceof jQuery) {\r\n        el = el[0];\r\n    }\r\n    try {\r\n        return el.getBoundingClientRect().top;\r\n    } catch (err) {\r\n        console.warn(\"cannot retrieve element for measuring top offset\");\r\n        return;\r\n    }\r\n}\r\n\r\nfunction get_offset(el) {\r\n    if (el instanceof jQuery) {\r\n        el = el[0];\r\n    }\r\n    try {\r\n        return el.getBoundingClientRect();\r\n    } catch (err) {\r\n        console.warn(\"cannot retrieve element for measuring top offset\");\r\n        return;\r\n    }\r\n}\r\n","/*\r\n * Created by Josh on 17/06/2017.\r\n */\r\n\r\nconst sound = function () {\r\n\r\n    var current_sound,\r\n        gain_node,\r\n        scratch_buffer,\r\n        current_theme;\r\n\r\n    const AUDIO_ELM = new Audio(),\r\n        CONTEXT = createAudioContext(),\r\n        ANALYSER = CONTEXT ? CONTEXT.createAnalyser() : false;\r\n\r\n    function createAudioContext(desiredSampleRate) {\r\n        var AudioCtor = window.AudioContext || window.webkitAudioContext;\r\n\r\n        if (!AudioCtor) {\r\n            return false;\r\n        }\r\n        desiredSampleRate = typeof desiredSampleRate === 'number'\r\n            ? desiredSampleRate\r\n            : 44100;\r\n        var context = new AudioCtor();\r\n\r\n        // Check if hack is necessary. Only occurs in iOS6+ devices\r\n        // and only when you first boot the iPhone, or play a audio/video\r\n        // with a different sample rate\r\n        context.onstatechange = function () {\r\n            if (context.state === 'suspended') {\r\n                context.resume();\r\n            }\r\n        };\r\n        return context\r\n    }\r\n\r\n    function unlock() {\r\n         if (!CONTEXT) {\r\n            return false;\r\n        }\r\n        scratch_buffer = CONTEXT.createBuffer(1, 1, 22050);\r\n\r\n\r\n        // Call this method on touch start to create and play a buffer,\r\n        // then check if the audio actually played to determine if\r\n        // audio has now been unlocked on iOS, Android, etc.\r\n        var unlock = function () {\r\n            // Fix Android can not play in suspend state.\r\n            // Create an empty buffer.\r\n            var source = CONTEXT.createBufferSource();\r\n            source.buffer = scratch_buffer;\r\n            source.connect(CONTEXT.destination);\r\n            //media.sound.iOS_unlocked = true;\r\n            // Play the empty buffer.\r\n            if (typeof source.start === 'undefined') {\r\n                source.noteOn(0);\r\n            } else {\r\n                source.start(0);\r\n            }\r\n\r\n            // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.\r\n            if (typeof CONTEXT.resume === 'function') {\r\n                CONTEXT.resume();\r\n            }\r\n\r\n            // Setup a timeout to check that we are unlocked on the next event loop.\r\n            source.onended = function () {\r\n                source.disconnect(0);\r\n\r\n                // Update the unlocked state and prevent this check from happening again.\r\n                //self._mobileEnabled = true;\r\n                //self.mobileAutoEnable = false;\r\n\r\n                // Remove the touch start listener.\r\n                document.removeEventListener('touchstart', unlock, true);\r\n                document.removeEventListener('touchend', unlock, true);\r\n            };\r\n        };\r\n\r\n        // Setup a touch start listener to attempt an unlock in.\r\n        document.addEventListener('touchstart', unlock, true);\r\n        document.addEventListener('touchend', unlock, true);\r\n    }\r\n\r\n    function play_blank() {\r\n\r\n        var buffer = CONTEXT.createBuffer(1, 1, 44100);\r\n        var dummy = CONTEXT.createBufferSource();\r\n        dummy.buffer = buffer;\r\n        dummy.connect(CONTEXT.destination);\r\n        dummy.start(0);\r\n        dummy.disconnect();\r\n\r\n        //CONTEXT.close(); // dispose old context\r\n        //context = new AudioCtor();\r\n    }\r\n\r\n    function delay_play(sound, dep, dep_args, volume) {\r\n        if ((dep && dep(dep_args)) || (sound.prevent && sound.prevent())) {\r\n            return;\r\n        }\r\n\r\n        if (current_theme && current_theme.isTheme && sound.isTheme) {\r\n            media.sound.stop(current_theme);\r\n        }\r\n        CONTEXT ? play_web_audio(sound, volume) : play_elm_audio(sound, volume);\r\n        current_sound = sound;\r\n        if (sound.isTheme)current_theme = sound;\r\n        console.log(\"SOUND PLAYED: \" + sound.id);\r\n    }\r\n\r\n    function web_audio_buffered(batch, cold, buffer) {\r\n        this.element = buffer;\r\n        /*\r\n         Data loaded and info is stored as buffer.\r\n         Runs the loaded/error callbacks in media.js\r\n         */\r\n        media.pre_load.load_finished({\r\n            data: {\r\n                asset: this,\r\n                batch: batch\r\n            },\r\n            success: buffer\r\n        });\r\n        /*\r\n         cold checks if the data has been played without being initially preloaded,\r\n         Then it plays the audio after being loaded. This will come with a delay frrom the preload time\r\n         */\r\n        if (cold) {\r\n            play_web_audio(this);\r\n        }\r\n    }\r\n\r\n    function web_audio_load(asset, batch, cold) {\r\n        CONTEXT.decodeAudioData(\r\n            this.response,\r\n            web_audio_buffered.bind(asset, batch, cold)\r\n        );\r\n    }\r\n\r\n    function load_web_audio(asset, batch, cold) {\r\n        return asset.promise = new Promise(function (resolve, reject) {\r\n            var xhr = new XMLHttpRequest();\r\n            xhr.open(\"GET\", asset.src, true);\r\n            xhr.responseType = \"arraybuffer\";\r\n            xhr.onload = function (progress) {\r\n                resolve(this, progress);\r\n            };\r\n            xhr.onerror = function () {\r\n                reject(error);\r\n            };\r\n            xhr.send();\r\n        })\r\n            .then(function (xhr, progress) {\r\n                CONTEXT.decodeAudioData(\r\n                    xhr.response,\r\n                    web_audio_buffered.bind(asset, batch, cold)\r\n                );\r\n            })\r\n    }\r\n\r\n    function stop_elm_audio(data) {\r\n        data.element.pause();\r\n        data.element.currentTime = 0;\r\n    }\r\n\r\n    function stop_web_audio(data) {\r\n        data.source[data.source.stop ? \"stop\" : \"noteOff\"](0);\r\n    }\r\n\r\n    function play_elm_audio(data, volume) {\r\n        data.element.currentTime = 0;\r\n        data.element.volume = 0;\r\n        data.element.play();\r\n    }\r\n\r\n    function play_web_audio(data, volume) {\r\n        if (!data) {\r\n            /*\r\n             If the sound is yet to be preloaded,\r\n             load the web audio then play after its loaded.\r\n             */\r\n            load_web_audio(data, false, true);\r\n            return;\r\n        }\r\n        var source = CONTEXT.createBufferSource();\r\n        source.buffer = data.element;\r\n\r\n        if (data.volume) {\r\n            gain_node = CONTEXT.createGain\r\n                ? CONTEXT.createGain()\r\n                : CONTEXT.createGainNode();\r\n            source.connect(gain_node);\r\n            gain_node.connect(CONTEXT.destination);\r\n            gain_node.gain.value = data.volume * (volume || 1);\r\n        } else {\r\n            source.connect(CONTEXT.destination);\r\n        }\r\n        source.loop = !!data.loop;\r\n        if (CONTEXT.state === \"suspended\") {\r\n            CONTEXT.resume();\r\n        }\r\n        source[source.start ? \"start\" : \"noteOn\"](0);\r\n        data.source = source;\r\n    }\r\n\r\n    unlock();\r\n\r\n    return {\r\n        SOUND_PATH: 'sounds/',\r\n        WEB_AUDIO: !!CONTEXT,\r\n        CONTEXT: CONTEXT,\r\n        EXTENSION: !!(\r\n        AUDIO_ELM.canPlayType &&\r\n        AUDIO_ELM.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/no/, \"\")\r\n        )\r\n            ? \".ogg\"\r\n            : \".mp3\",\r\n\r\n        /*\r\n         Plays any audio matching the id.\r\n         */\r\n        play(id, del, dep, dep_args, volume) {\r\n            if (id === 'blank') {\r\n                play_blank();\r\n                return;\r\n            }\r\n            //if(device.o_s === 'iOS' && !media.sound.iOS_unlocked){\r\n            //    return;\r\n            //}\r\n            var sound = id.key ? id : media.get(\"sounds\", id);\r\n            if (del) {\r\n                TweenMax.delayedCall(del, delay_play, [\r\n                    sound,\r\n                    dep,\r\n                    dep_args,\r\n                    volume\r\n                ]);\r\n            } else {\r\n                delay_play(sound, dep, dep_args, volume);\r\n            }\r\n        },\r\n        /*\r\n         Stops any audio matching the id.\r\n         */\r\n        stop(id) {\r\n            var sound = id.key ? id : media.get(\"sounds\", id);\r\n            CONTEXT ? stop_web_audio(sound) : stop_elm_audio(sound);\r\n            console.log('SOUND STOPPED: ' + id);\r\n        },\r\n        /*\r\n         Loads any audio matching the id. This is only supported for webAudio\r\n         */\r\n        load(id, batch) {\r\n            var sound = id.id ? id : media.get(\"sounds\", id);\r\n            if (CONTEXT) load_web_audio(sound, batch);\r\n        }\r\n    }\r\n}();\r\n"]}